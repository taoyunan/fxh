<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Steam 拼图工具 - 完整版（带吸附+行间距+同步拖动+默认文字）</title>
<style>
  body {
    background: #1b1f27;
    color: #fff;
    font-family: "微软雅黑", sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
  }
  h1 { margin-bottom: 15px; }
  .controls {
    display: flex;
    gap: 10px;
    margin-bottom: 10px;
    width: 100%;
    max-width: 800px;
    flex-wrap: wrap;
  }
  input, button, select {
    padding: 10px 15px;
    font-size: 14px;
    border: none;
    border-radius: 5px;
    outline: none;
  }
  input[type="color"], input[type="number"] {
    padding: 5px;
  }
  input { flex: 1; }
  button {
    background: #4cafef;
    color: white;
    cursor: pointer;
    user-select: none;
    transition: background-color 0.2s;
  }
  button:hover { background: #369bd6; }
  #canvas-container {
    border: 2px solid #333;
    background: #222;
    width: 1200px;
    height: 278px;
    position: relative;
  }
  canvas { display: block; user-select: none; cursor: grab; }
  .slider-container {
    margin-top: 15px;
    width: 600px;
    display: flex;
    align-items: center;
    gap: 10px;
    color: #ddd;
  }
  input[type="range"] { flex: 1; }
  #error {
    margin-top: 15px;
    color: #f44336;
    font-weight: bold;
    min-height: 1.5em;
  }
  #loading { margin-top: 10px; color: #66ccff; }
  #tutorial {
    max-width: 800px;
    text-align: left;
    margin-top: 30px;
    padding: 15px;
    background: #2a2f3a;
    border-radius: 10px;
    font-size: 14px;
    line-height: 1.6;
  }
</style>
</head>
<body>

<h1>Steam 拼图工具 - 完整版</h1>

<div class="controls">
  <input id="appId" placeholder="请输入 Steam App ID，例如：2962810" />
  <button id="fetchBtn">获取并合成</button>
  <button id="saveBtn" disabled>保存图片</button>
</div>

<div class="controls">
  <input id="customText" placeholder="输入自定义文字（支持多行）" />
  <input type="color" id="textColor" value="#ffffff" />
  <input type="number" id="textSize" value="24" min="8" max="200" />
  <input type="number" id="lineSpacing" value="5" min="0" max="100" title="行间距" />
  <select id="textFont">
    <option value="微软雅黑">微软雅黑</option>
    <option value="黑体">黑体</option>
    <option value="Arial">Arial</option>
    <option value="Times New Roman">Times New Roman</option>
  </select>
</div>

<div id="canvas-container">
  <canvas id="heroCanvas" width="1200" height="278" title="拖动Logo或文字微调位置"></canvas>
</div>

<div class="slider-container">
  <label for="scaleSlider">缩放 Logo:</label>
  <input type="range" id="scaleSlider" min="10" max="200" value="100" disabled />
  <span id="scalePercent">100%</span>
</div>

<div id="loading"></div>
<div id="error"></div>

<div id="tutorial">
  <h3>使用教程：</h3>
  <ul>
    <li>输入 Steam App ID 点击“获取并合成”加载背景和 Logo。</li>
    <li>默认文字会填充为 <code>3DM《游戏名》专区</code>，可自行修改。</li>
    <li>可以输入多行文字，调整颜色、字号、字体和行间距。</li>
    <li>用鼠标拖动 Logo 或文字来改变位置。</li>
    <li><b>自动吸附：</b>拖动到画布水平/垂直中心附近会自动对齐。</li>
    <li><b>同步拖动：</b>按住 Shift 键拖动任意一个元素，Logo 和文字会一起移动。</li>
    <li>调整 Logo 缩放比例，用“保存图片”按钮导出 PNG。</li>
  </ul>
</div>

<script>
  const API_BASE = "https://api.steamcmd.net/v1/info/";
  const IMG_BASE = "https://shared.fastly.steamstatic.com/store_item_assets/steam/apps/";
  const snapThreshold = 10; // 吸附阈值

  const canvas = document.getElementById("heroCanvas");
  const ctx = canvas.getContext("2d");
  const errorBox = document.getElementById("error");
  const loadingBox = document.getElementById("loading");
  const scaleSlider = document.getElementById("scaleSlider");
  const scalePercent = document.getElementById("scalePercent");
  const saveBtn = document.getElementById("saveBtn");

  let heroImg = new Image();
  let logoImg = new Image();
  let logoX = 0, logoY = 0, logoScale = 1;
  let customText = "", textColor = "#ffffff", textSize = 24, textFont = "微软雅黑";
  let textX = 20, textY = 20, lineSpacing = 5;

  let dragging = false;
  let dragTarget = null;
  let dragOffsetX = 0, dragOffsetY = 0;

  function clearError() { errorBox.textContent = ""; }
  function showError(msg) { errorBox.textContent = msg; }
  function setLoading(msg) { loadingBox.textContent = msg; }
  function clearLoading() { loadingBox.textContent = ""; }

  function drawHero(img) {
    const cw = canvas.width, ch = canvas.height;
    ctx.clearRect(0, 0, cw, ch);
    const scale = Math.max(cw / img.width, ch / img.height);
    const w = img.width * scale, h = img.height * scale;
    ctx.drawImage(img, (cw - w) / 2, (ch - h) / 2, w, h);
  }
  function drawLogo() {
    if (!logoImg.complete) return;
    ctx.drawImage(logoImg, logoX, logoY, logoImg.width * logoScale, logoImg.height * logoScale);
  }
  function drawText() {
    if (!customText) return;
    ctx.font = `${textSize}px "${textFont}"`;
    ctx.fillStyle = textColor;
    ctx.textBaseline = "top";
    const lines = customText.split("\n");
    lines.forEach((line, i) => {
      ctx.fillText(line, textX, textY + i * (textSize + lineSpacing));
    });
  }
  function drawAll() {
    drawHero(heroImg);
    drawLogo();
    drawText();
  }
  function initLogoPosition(logoPos) {
    const cw = canvas.width, ch = canvas.height;
    logoScale = (0.2 * cw) / logoImg.width;
    const widthPct = parseFloat(logoPos.width_pct);
    const heightPct = parseFloat(logoPos.height_pct);
    const pinned = (logoPos.pinned_position || "").toLowerCase();
    const logoW = logoImg.width * logoScale;
    const logoH = logoImg.height * logoScale;
    logoX = pinned.includes("right") ? cw - (widthPct / 100) * cw - logoW : (widthPct / 100) * cw;
    logoY = pinned.includes("bottom") ? ch - (heightPct / 100) * ch - logoH : (heightPct / 100) * ch;
    scaleSlider.value = Math.round(logoScale * 100);
    scalePercent.textContent = `${Math.round(logoScale * 100)}%`;
    scaleSlider.disabled = false;
    saveBtn.disabled = false;
  }
  function snapToCenterX(objX, objW) {
    const centerX = (canvas.width - objW) / 2;
    return Math.abs(objX - centerX) < snapThreshold ? centerX : objX;
  }
  function snapToCenterY(objY, objH) {
    const centerY = (canvas.height - objH) / 2;
    return Math.abs(objY - centerY) < snapThreshold ? centerY : objY;
  }

  canvas.addEventListener("mousedown", (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left, my = e.clientY - rect.top;
    const logoW = logoImg.width * logoScale, logoH = logoImg.height * logoScale;
    const textW = ctx.measureText(customText.split("\n")[0] || "").width;
    const textH = customText.split("\n").length * (textSize + lineSpacing) - lineSpacing;
    if (e.shiftKey) {
      dragTarget = "both";
      dragOffsetX = mx - logoX;
      dragOffsetY = my - logoY;
    } else if (mx >= logoX && mx <= logoX + logoW && my >= logoY && my <= logoY + logoH) {
      dragTarget = "logo";
      dragOffsetX = mx - logoX;
      dragOffsetY = my - logoY;
    } else if (mx >= textX && mx <= textX + textW && my >= textY && my <= textY + textH) {
      dragTarget = "text";
      dragOffsetX = mx - textX;
      dragOffsetY = my - textY;
    }
    if (dragTarget) {
      dragging = true;
      canvas.style.cursor = "grabbing";
    }
  });

  canvas.addEventListener("mousemove", (e) => {
    if (!dragging) return;
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left, my = e.clientY - rect.top;
    if (dragTarget === "logo" || dragTarget === "both") {
      let newX = Math.max(0, Math.min(mx - dragOffsetX, canvas.width - logoImg.width * logoScale));
      let newY = Math.max(0, Math.min(my - dragOffsetY, canvas.height - logoImg.height * logoScale));
      newX = snapToCenterX(newX, logoImg.width * logoScale);
      newY = snapToCenterY(newY, logoImg.height * logoScale);
      if (dragTarget === "logo") {
        logoX = newX; logoY = newY;
      } else {
        let offsetX = newX - logoX, offsetY = newY - logoY;
        logoX = newX; logoY = newY;
        textX += offsetX; textY += offsetY;
      }
    }
    if (dragTarget === "text" && dragTarget !== "both") {
      let textW = ctx.measureText(customText.split("\n")[0] || "").width;
      let textH = customText.split("\n").length * (textSize + lineSpacing) - lineSpacing;
      let newX = Math.max(0, Math.min(mx - dragOffsetX, canvas.width));
      let newY = Math.max(0, Math.min(my - dragOffsetY, canvas.height));
      newX = snapToCenterX(newX, textW);
      newY = snapToCenterY(newY, textH);
      textX = newX; textY = newY;
    }
    drawAll();
  });

  ["mouseup","mouseleave"].forEach(evt => {
    canvas.addEventListener(evt, () => { dragging = false; dragTarget = null; canvas.style.cursor = "grab"; });
  });

  scaleSlider.addEventListener("input", (e) => {
    logoScale = e.target.value / 100;
    scalePercent.textContent = `${e.target.value}%`;
    drawAll();
  });

  saveBtn.addEventListener("click", () => {
    const link = document.createElement("a");
    link.download = `steam_${document.getElementById("appId").value.trim()}.png`;
    link.href = canvas.toDataURL("image/png");
    link.click();
  });

  document.getElementById("customText").addEventListener("input", (e) => { customText = e.target.value; drawAll(); });
  document.getElementById("textColor").addEventListener("input", (e) => { textColor = e.target.value; drawAll(); });
  document.getElementById("textSize").addEventListener("input", (e) => { textSize = parseInt(e.target.value, 10); drawAll(); });
  document.getElementById("textFont").addEventListener("change", (e) => { textFont = e.target.value; drawAll(); });
  document.getElementById("lineSpacing").addEventListener("input", (e) => { lineSpacing = parseInt(e.target.value, 10); drawAll(); });

  async function fetchData(appId) {
    clearError(); setLoading("加载中，请稍候..."); saveBtn.disabled = true; scaleSlider.disabled = true;
    try {
      const res = await fetch(API_BASE + appId);
      if (!res.ok) throw new Error(`API 请求失败，状态码: ${res.status}`);
      const json = await res.json();
      const appData = json.data?.[appId];
      if (!appData) throw new Error("未找到游戏数据");

      // 自动填充默认文字
      let gameName = appData.common?.name_localized?.sc_schinese 
                  || appData.common?.metacritic_name 
                  || "";
      customText = `3DM《${gameName}》专区`;
      document.getElementById("customText").value = customText;

      const assetsFull = appData.common?.library_assets_full;
      if (!assetsFull) throw new Error("缺少 library_assets_full 数据");
      let lang = "schinese";
      if (!assetsFull.library_hero?.image?.[lang] && !assetsFull.library_logo?.image?.[lang]) lang = "english";
      const heroPath = assetsFull.library_hero?.image?.[lang];
      const logoPath = assetsFull.library_logo?.image?.[lang];
      if (!heroPath) throw new Error("未找到 library_hero 图片路径");
      if (!logoPath) throw new Error("未找到 library_logo 图片路径");
      const logoPos = assetsFull.library_logo?.logo_position || appData.common.library_assets?.logo_position;
      if (!logoPos) throw new Error("缺少 logo_position 数据");
      heroImg = new Image(); heroImg.crossOrigin = "anonymous"; heroImg.src = IMG_BASE + appId + "/" + heroPath;
      logoImg = new Image(); logoImg.crossOrigin = "anonymous"; logoImg.src = IMG_BASE + appId + "/" + logoPath;
      await Promise.all([ new Promise(r => heroImg.onload = r), new Promise(r => logoImg.onload = r) ]);
      drawHero(heroImg); initLogoPosition(logoPos); drawAll(); clearLoading();
    } catch (e) { showError(e.message || "未知错误"); clearLoading(); }
  }

  document.getElementById("fetchBtn").addEventListener("click", () => {
    const id = document.getElementById("appId").value.trim();
    if (!id) { showError("请输入有效的 Steam App ID"); return; }
    fetchData(id);
  });
</script>
</body>
</html>
